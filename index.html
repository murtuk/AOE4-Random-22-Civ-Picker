<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AoE4 Visual Random Civ Picker</title>
  <style>
    :root{
      --bg0:#070a10; --bg1:#0b1020; --card:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.12); --text:#eaf0ff; --muted:#a9b7d6;
      --good:#7dffb2; --warn:#ffda7d; --bad:#ff7d7d;
      --shadow: 0 16px 40px rgba(0,0,0,.45);
      --r:18px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
    }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 30% -10%, #1a2a50 0%, transparent 60%),
        radial-gradient(900px 500px at 110% 10%, #3a1f2a 0%, transparent 60%),
        radial-gradient(1200px 700px at 50% 120%, #113b2b 0%, transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }
    .wrap{ max-width: 1100px; margin:0 auto; padding: 24px 16px 40px; }
    header{
      display:flex; gap:14px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap;
      margin-bottom: 14px;
    }
    h1{ margin:0; font-size: 22px; letter-spacing:.3px; }
    .sub{ margin:6px 0 0; color: var(--muted); font-size: 13px; }
    .pillbar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .pill{
      padding: 8px 10px; border-radius: 999px; border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06); font-size: 12px; color: var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    .pill b{ color: var(--text); font-weight: 700; }

    .grid{
      display:grid; grid-template-columns: 1fr; gap: 14px;
    }
    @media (min-width: 980px){
      .grid{ grid-template-columns: 420px 1fr; align-items:start; }
    }

    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .pad{ padding: 14px; }

    /* RESULT PANEL */
    .hero{
      position:relative;
      padding: 16px;
      background:
        radial-gradient(800px 260px at 20% 0%, rgba(255,255,255,.08), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-bottom: 1px solid var(--stroke);
    }
    .resultRow{ display:flex; gap: 14px; align-items:center; }
    .emblem{
      width: 92px; height: 92px; border-radius: 18px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.25);
      display:grid; place-items:center;
      overflow:hidden;
      flex: 0 0 auto;
    }
    .emblem img{ width:100%; height:100%; object-fit: cover; }
    .emblem .ph{
      width:100%; height:100%;
      display:grid; place-items:center;
      color: rgba(255,255,255,.6);
      font-size: 30px; font-weight: 900;
      background:
        radial-gradient(60px 60px at 30% 30%, rgba(255,255,255,.10), transparent 60%),
        radial-gradient(70px 70px at 80% 80%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
    }
    .pickedName{ font-size: 22px; font-weight: 900; margin:0; }
    .pickedMeta{ margin:6px 0 0; color: var(--muted); font-size: 12px; }

    .btnRow{ display:flex; flex-wrap:wrap; gap: 10px; margin-top: 12px; }
    button{
      cursor:pointer;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 800;
      letter-spacing:.2px;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .opts{
      display:grid; gap:10px;
      margin-top: 12px;
    }
    .opt{
      display:flex; gap:10px; align-items:center;
      color: var(--muted); font-size: 13px;
      user-select:none;
    }
    .opt input{ transform: scale(1.1); }

    .note{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .banner{
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
      color: var(--muted);
      display:none;
    }
    .banner.show{ display:block; }
    .banner .bad{ color: var(--warn); font-weight: 800; }

    /* CIV GRID */
    .toolbar{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(255,255,255,.03);
    }
    .toolbar .left{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .toolbar input[type="search"]{
      width: min(360px, 72vw);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
    }
    .toolbar .smallBtn{
      padding: 10px 10px;
      font-weight: 800;
    }
    .count{ color: var(--muted); font-size: 12px; }

    .civGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      padding: 14px;
    }
    @media (min-width: 720px){
      .civGrid{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
    }
    @media (min-width: 980px){
      .civGrid{ grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }

    .civCard{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      overflow:hidden;
      cursor:pointer;
      position:relative;
      transition: transform 120ms ease, filter 120ms ease, opacity 120ms ease;
      user-select:none;
    }
    .civCard:hover{ transform: translateY(-2px); }
    .civCard.disabled{ opacity: .38; filter: grayscale(1); }
    .civCard.picked{
      outline: 2px solid rgba(125,255,178,.9);
      box-shadow: 0 0 0 6px rgba(125,255,178,.10), var(--shadow);
      transform: translateY(-2px);
    }
    .thumb{
      height: 92px;
      background:
        radial-gradient(80px 80px at 30% 30%, rgba(255,255,255,.10), transparent 55%),
        linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      display:grid; place-items:center;
      overflow:hidden;
    }
    .thumb img{ width:100%; height:100%; object-fit: cover; }
    .thumb .skeleton{
      width: 46px; height: 46px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.15);
      animation: pulse 1.1s infinite ease-in-out;
    }
    @keyframes pulse{
      0%{ opacity:.55 } 50%{ opacity:.95 } 100%{ opacity:.55 }
    }
    .civName{
      padding: 10px 10px 12px;
      font-weight: 900;
      font-size: 12.5px;
      letter-spacing: .2px;
      line-height: 1.2;
      min-height: 38px;
      display:flex; align-items:center;
    }
    .tag{
      position:absolute; top:8px; right:8px;
      font-size: 10px;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.28);
      color: rgba(255,255,255,.75);
      backdrop-filter: blur(6px);
    }

    /* HISTORY */
    .history{ padding: 0 14px 14px; }
    .history h3{ margin: 0; padding: 10px 0 6px; font-size: 13px; }
    ol{ margin: 0; padding-left: 18px; color: rgba(255,255,255,.82); }
    li{ margin: 6px 0; font-size: 12.5px; color: rgba(255,255,255,.85); }

    /* TOAST */
    .toast{
      position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
      background: rgba(10, 16, 30, 0.92);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      opacity: 0; pointer-events: none;
      transition: opacity 180ms ease;
      font-size: 13px;
    }
    .toast.show{ opacity: 1; }

    canvas.confetti{
      position: fixed; inset:0;
      pointer-events:none;
      display:none;
    }
    canvas.confetti.show{ display:block; }
  </style>
</head>
<body>
  <canvas id="confetti" class="confetti"></canvas>

  <div class="wrap">
    <header>
      <div>
        <h1>AoE4 Visual Random Civ Picker</h1>
        <p class="sub">Click civ cards to enable/disable. Press <b>Space</b> to pick.</p>
      </div>
      <div class="pillbar">
        <div class="pill">Enabled: <b id="enabledCount">0</b></div>
        <div class="pill">Images loaded: <b id="imgCount">0</b>/<span id="totalCount">0</span></div>
      </div>
    </header>

    <div class="grid">
      <!-- Left: picker -->
      <section class="card">
        <div class="hero">
          <div class="resultRow">
            <div class="emblem" id="pickedEmblem">
              <div class="ph" id="pickedPh">?</div>
            </div>
            <div>
              <p class="pickedName" id="pickedName">—</p>
              <p class="pickedMeta" id="pickedMeta">Pick a civilization to start</p>
            </div>
          </div>

          <div class="btnRow">
            <button id="pickBtn">Pick random civ</button>
            <button id="copyBtn" disabled>Copy</button>
            <button id="resetBtn" title="Resets no-repeat bag, clears history, removes highlights">Reset</button>
          </div>

          <div class="opts">
            <label class="opt"><input type="checkbox" id="noRepeat"> No repeats until all enabled civs are used</label>
            <label class="opt"><input type="checkbox" id="animate" checked> Shuffle animation</label>
            <label class="opt"><input type="checkbox" id="confettiToggle" checked> Confetti on pick</label>
            <label class="opt"><input type="checkbox" id="loadImages" checked> Load images from Fandom wiki</label>
          </div>

          <div class="banner" id="imgWarn">
            <span class="bad">Images didn’t load.</span> This usually happens if you opened the file with <b>file://</b>.
            Run a local server (instructions below) and refresh.
          </div>

          <div class="note">
            Images are fetched from the Age of Empires Fandom wiki via the MediaWiki API (needs internet).
            If some civ pages don’t exist there, those civs will show a placeholder.
          </div>
        </div>

        <div class="history">
          <h3>History (last 10)</h3>
          <ol id="history"></ol>
        </div>
      </section>

      <!-- Right: civ grid -->
      <section class="card">
        <div class="toolbar">
          <div class="left">
            <input id="search" type="search" placeholder="Filter civs..." autocomplete="off" />
            <button class="smallBtn" id="enableAll">Enable all</button>
            <button class="smallBtn" id="disableAll">Disable all</button>
          </div>
          <div class="count" id="filteredCount">—</div>
        </div>
        <div class="civGrid" id="civGrid"></div>
      </section>
    </div>
  </div>

  <div class="toast" id="toast">Copied!</div>

  <script>
      const CIVS = [
      "Abbasid Dynasty",
      "Ayyubids",
      "Byzantines",
      "Chinese",
      "Delhi Sultanate",
      "French",
      "English",
      "Golden Horde",
      "HRE",
      "House of Lancaster",
      "Japanese",
      "Jeanne d Arc",
      "Knights Templar",
      "Macedonian Dynast",
      "Malians",
      "Mongols",
      "Order of the Dragon",
      "Ottomans",
      "Rus",
      "Sengoku Daimyo",
      "Tughlaq Dynasty",
      "Zhu Xis Legacy"
    ];

   const WIKI_TITLE_OVERRIDES = {
  "HRE": "Holy_Roman_Empire",
  "Jeanne d Arc": "Jeanne_d'Arc",
  "Macedonian Dynast": "Macedonian_Dynasty",
  "Zhu Xis Legacy": "Zhu_Xi's_Legacy",

  "Byzantines": "Byzantines_(Age_of_Empires_IV)",
  "Chinese": "Chinese_(Age_of_Empires_IV)",
  "French": "French_(Age_of_Empires_IV)",
  "Japanese": "Japanese_(Age_of_Empires_IV)",
  "Malians": "Malians_(Age_of_Empires_IV)",
  "Mongols": "Mongols_(Age_of_Empires_IV)",
  "Ottomans": "Ottomans_(Age_of_Empires_IV)"
};


    
    const API = "https://ageofempires.fandom.com/api.php";

    
    const KEY_ENABLED = "aoe4_visual_enabled_v1";
    const KEY_BAG = "aoe4_visual_bag_v1";
    const KEY_HISTORY = "aoe4_visual_history_v1";
    const KEY_OPTS = "aoe4_visual_opts_v1";
    const KEY_IMG_CACHE = "aoe4_visual_imgcache_v1";

    
    const civGrid = document.getElementById("civGrid");
    const enabledCountEl = document.getElementById("enabledCount");
    const imgCountEl = document.getElementById("imgCount");
    const totalCountEl = document.getElementById("totalCount");
    const filteredCountEl = document.getElementById("filteredCount");

    const pickedNameEl = document.getElementById("pickedName");
    const pickedMetaEl = document.getElementById("pickedMeta");
    const pickedEmblemEl = document.getElementById("pickedEmblem");
    const pickedPhEl = document.getElementById("pickedPh");

    const pickBtn = document.getElementById("pickBtn");
    const copyBtn = document.getElementById("copyBtn");
    const resetBtn = document.getElementById("resetBtn");

    const noRepeatEl = document.getElementById("noRepeat");
    const animateEl = document.getElementById("animate");
    const confettiToggleEl = document.getElementById("confettiToggle");
    const loadImagesEl = document.getElementById("loadImages");

    const enableAllBtn = document.getElementById("enableAll");
    const disableAllBtn = document.getElementById("disableAll");
    const searchEl = document.getElementById("search");

    const historyEl = document.getElementById("history");
    const toastEl = document.getElementById("toast");
    const imgWarnEl = document.getElementById("imgWarn");

    
    const confettiCanvas = document.getElementById("confetti");
    const ctx = confettiCanvas.getContext("2d");

    
    let enabledMap = loadJSON(KEY_ENABLED, null);
    if (!enabledMap) {
      enabledMap = {};
      for (const c of CIVS) enabledMap[c] = true;
      saveJSON(KEY_ENABLED, enabledMap);
    } else {
      for (const c of CIVS) if (!(c in enabledMap)) enabledMap[c] = true;
    }

    let bag = loadJSON(KEY_BAG, []);
    let history = loadJSON(KEY_HISTORY, []);
    let imgCache = loadJSON(KEY_IMG_CACHE, {}); 

    const defaultOpts = { noRepeat:false, animate:true, confetti:true, loadImages:true };
    const opts = { ...defaultOpts, ...loadJSON(KEY_OPTS, {}) };
    noRepeatEl.checked = !!opts.noRepeat;
    animateEl.checked = !!opts.animate;
    confettiToggleEl.checked = opts.confetti !== false;
    loadImagesEl.checked = opts.loadImages !== false;

    totalCountEl.textContent = String(CIVS.length);

    let lastPicked = null;

    
    function loadJSON(key, fallback){
      try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }
      catch{ return fallback; }
    }
    function saveJSON(key, val){
      try{ localStorage.setItem(key, JSON.stringify(val)); } catch {}
    }

    function showToast(text){
      toastEl.textContent = text;
      toastEl.classList.add("show");
      setTimeout(()=>toastEl.classList.remove("show"), 900);
    }

    function getEnabledCivs(){
      return CIVS.filter(c => enabledMap[c] !== false);
    }

    function updateEnabledCount(){
      const n = getEnabledCivs().length;
      enabledCountEl.textContent = String(n);
      pickBtn.disabled = (n === 0);
      filteredCountEl.textContent = `${n} enabled • ${getFilteredCivs().length} shown`;
    }

    function titleFor(civName){
      return WIKI_TITLE_OVERRIDES[civName] || civName.replaceAll(" ", "_");
    }

    function pickRandom(arr){
      const i = Math.floor(Math.random() * arr.length);
      return arr[i];
    }

    function rebuildBag(){
      if (!noRepeatEl.checked) return;
      const enabled = new Set(getEnabledCivs());
      bag = bag.filter(x => enabled.has(x));
      if (bag.length === 0) bag = [...enabled];
      saveJSON(KEY_BAG, bag);
    }

    function renderHistory(){
      historyEl.innerHTML = "";
      for (const h of history.slice(0,10)){
        const li = document.createElement("li");
        li.textContent = h;
        historyEl.appendChild(li);
      }
    }

    function setPicked(civName){
      lastPicked = civName;
      pickedNameEl.textContent = civName || "—";
      pickedMetaEl.textContent = civName ? "Selected" : "Pick a civilization to start";
      copyBtn.disabled = !civName;

      
      const t = civName ? titleFor(civName) : null;
      const url = t && imgCache[t]?.url ? imgCache[t].url : null;

      pickedEmblemEl.innerHTML = "";
      if (url){
        const img = new Image();
        img.alt = civName;
        img.src = url;
        pickedEmblemEl.appendChild(img);
      } else {
        const ph = document.createElement("div");
        ph.className = "ph";
        ph.textContent = civName ? civName.trim()[0].toUpperCase() : "?";
        pickedEmblemEl.appendChild(ph);
      }

      
      document.querySelectorAll(".civCard").forEach(el => el.classList.remove("picked"));
      const card = document.querySelector(`.civCard[data-name="${cssEscape(civName)}"]`);
      if (card) card.classList.add("picked");
    }

    
    function cssEscape(s){
      if (!s) return "";
      return s.replace(/["\\]/g, "\\$&");
    }

    
    function getFilteredCivs(){
      const q = searchEl.value.trim().toLowerCase();
      if (!q) return CIVS.slice();
      return CIVS.filter(c => c.toLowerCase().includes(q));
    }

    
    function renderGrid(){
      const list = getFilteredCivs();
      civGrid.innerHTML = "";

      for (const civ of list){
        const card = document.createElement("div");
        card.className = "civCard";
        card.dataset.name = civ;
        if (enabledMap[civ] === false) card.classList.add("disabled");

        const thumb = document.createElement("div");
        thumb.className = "thumb";

        const wikiTitle = titleFor(civ);
        const cached = imgCache[wikiTitle]?.url;

        if (loadImagesEl.checked && cached){
          const img = new Image();
          img.alt = civ;
          img.src = cached;
          thumb.appendChild(img);
        } else {
          const sk = document.createElement("div");
          sk.className = "skeleton";
          thumb.appendChild(sk);
        }

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = enabledMap[civ] === false ? "OFF" : "ON";

        const name = document.createElement("div");
        name.className = "civName";
        name.textContent = civ;

        card.appendChild(thumb);
        card.appendChild(tag);
        card.appendChild(name);

        card.addEventListener("click", () => {
          enabledMap[civ] = !(enabledMap[civ] === true);
          saveJSON(KEY_ENABLED, enabledMap);
          rebuildBag();
          renderGrid();
          updateEnabledCount();
        });

        civGrid.appendChild(card);
      }

      updateEnabledCount();
      updateImgCount();
      
      if (lastPicked) setPicked(lastPicked);
    }

    function updateImgCount(){
      let loaded = 0;
      for (const civ of CIVS){
        const t = titleFor(civ);
        if (imgCache[t]?.url) loaded++;
      }
      imgCountEl.textContent = String(loaded);
    }

    const CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 14;

    async function fetchPageImageByTitle(title){
  const params = new URLSearchParams({
    action: "query",
    format: "json",
    origin: "*",
    redirects: "1",
    prop: "pageimages",
    piprop: "thumbnail|original",
    pithumbsize: "320",
    titles: title
  });

  const res = await fetch(`${API}?${params.toString()}`);
  if (!res.ok) throw new Error("pageimages request failed");

  const json = await res.json();
  const pages = json?.query?.pages;
  if (!pages) return null;

  const firstKey = Object.keys(pages)[0];
  const page = pages[firstKey];

  
  return page?.thumbnail?.source || page?.original?.source || null;
}


    async function searchBestTitle(query){
     const params = new URLSearchParams({
        action: "query",
        format: "json",
        origin: "*",
        list: "search",
        srsearch: query,
        srlimit: "1"
      });
      const res = await fetch(`${API}?${params.toString()}`);
      if (!res.ok) return null;
      const json = await res.json();
      const hit = json?.query?.search?.[0];
      return hit?.title || null;
    }

    function cacheSet(title, url){
      imgCache[title] = { url, t: Date.now() };
      saveJSON(KEY_IMG_CACHE, imgCache);
    }

    function cacheFresh(title){
      const e = imgCache[title];
      if (!e?.url) return false;
      if (!e.t) return true;
      return (Date.now() - e.t) < CACHE_TTL_MS;
    }

    async function loadImages(){
      if (!loadImagesEl.checked) return;

      imgWarnEl.classList.remove("show");

      
      const tasks = [];
      for (const civ of CIVS){
        const t = titleFor(civ);
        if (cacheFresh(t)) continue;
        tasks.push({ civ, title: t });
      }
      if (tasks.length === 0){
        renderGrid();
        return;
      }

      let anyFailed = false;

      
      const CONC = 4;
      let idx = 0;

      async function worker(){
        while (idx < tasks.length){
          const cur = tasks[idx++];
          try{
            let url = await fetchPageImageByTitle(cur.title);
            if (!url){
              const bestTitle = await searchBestTitle(cur.civ);
              if (bestTitle) url = await fetchPageImageByTitle(bestTitle);
              if (url && bestTitle && bestTitle !== cur.title){
                cacheSet(bestTitle, url);
              }
            }
            if (url) cacheSet(cur.title, url);
          } catch {
            anyFailed = true;
          } finally {
            updateImgCount();
          }
        }
      }

      const workers = Array.from({length: CONC}, () => worker());
      await Promise.all(workers);

      renderGrid();

      
      const loaded = Number(imgCountEl.textContent || "0");
      if (loaded === 0 && anyFailed){
        imgWarnEl.classList.add("show");
      }
    }

   
    async function doPick(){
      const enabled = getEnabledCivs();
      if (enabled.length === 0) return;

      const visibleCards = [...document.querySelectorAll(".civCard")];

      
      if (animateEl.checked){
        const start = performance.now();
        while (performance.now() - start < 900){
          const r = pickRandom(enabled);
          setPicked(r);
          await sleep(60);
        }
      }

      let chosen = null;
      if (noRepeatEl.checked){
        rebuildBag();
        chosen = pickRandom(bag);
        bag = bag.filter(x => x !== chosen);
        saveJSON(KEY_BAG, bag);
      } else {
        chosen = pickRandom(enabled);
      }

      setPicked(chosen);

      history.unshift(chosen);
      history = history.slice(0, 10);
      saveJSON(KEY_HISTORY, history);
      renderHistory();

      if (confettiToggleEl.checked) fireConfetti();
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function copyPicked(){
      const text = (pickedNameEl.textContent || "").trim();
      if (!text || text === "—") return;
      try{
        await navigator.clipboard.writeText(text);
        showToast("Copied!");
      } catch {
        showToast("Clipboard blocked by browser.");
      }
    }

    
    function resetAll(){
      bag = [];
      history = [];
      saveJSON(KEY_BAG, bag);
      saveJSON(KEY_HISTORY, history);
      renderHistory();

      document.querySelectorAll(".civCard").forEach(el => el.classList.remove("picked"));
      setPicked(null);
      rebuildBag();
      showToast("Reset done");
    }

    
    let confettiTimer = null;
    function resizeCanvas(){
      confettiCanvas.width = window.innerWidth * devicePixelRatio;
      confettiCanvas.height = window.innerHeight * devicePixelRatio;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function fireConfetti(){
      if (confettiTimer) clearTimeout(confettiTimer);
      confettiCanvas.classList.add("show");

      const pieces = [];
      const W = window.innerWidth, H = window.innerHeight;

      for (let i=0;i<120;i++){
        pieces.push({
          x: Math.random()*W,
          y: -20 - Math.random()*200,
          vx: (Math.random()-.5)*3,
          vy: 2 + Math.random()*5,
          r: 2 + Math.random()*5,
          a: Math.random()*Math.PI*2,
          va: (Math.random()-.5)*0.25,
          life: 80 + Math.random()*60
        });
      }

      let frame = 0;
      function tick(){
        frame++;
        ctx.clearRect(0,0,W,H);
        for (const p of pieces){
          p.x += p.vx;
          p.y += p.vy;
          p.a += p.va;
          p.vy += 0.02; 
          p.life -= 1;

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.a);
          ctx.globalAlpha = Math.max(0, Math.min(1, p.life/140));
          ctx.fillRect(-p.r, -p.r/2, p.r*2, p.r);
          ctx.globalAlpha *= 0.35;
          ctx.fillRect(-p.r, -p.r/2, p.r*2, p.r/3);
          ctx.restore();
        }

        const alive = pieces.some(p => p.life > 0 && p.y < H + 40);
        if (alive && frame < 220){
          requestAnimationFrame(tick);
        } else {
          confettiCanvas.classList.remove("show");
          ctx.clearRect(0,0,W,H);
        }
      }
      requestAnimationFrame(tick);

      confettiTimer = setTimeout(()=> {
        confettiCanvas.classList.remove("show");
        ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
      }, 2600);
    }

    
    pickBtn.addEventListener("click", doPick);
    copyBtn.addEventListener("click", copyPicked);
    resetBtn.addEventListener("click", resetAll);

    enableAllBtn.addEventListener("click", () => {
      for (const c of CIVS) enabledMap[c] = true;
      saveJSON(KEY_ENABLED, enabledMap);
      rebuildBag();
      renderGrid();
    });
    disableAllBtn.addEventListener("click", () => {
      for (const c of CIVS) enabledMap[c] = false;
      saveJSON(KEY_ENABLED, enabledMap);
      rebuildBag();
      renderGrid();
    });

    searchEl.addEventListener("input", () => renderGrid());

    noRepeatEl.addEventListener("change", () => {
      opts.noRepeat = noRepeatEl.checked;
      saveJSON(KEY_OPTS, opts);
      rebuildBag();
    });
    animateEl.addEventListener("change", () => {
      opts.animate = animateEl.checked;
      saveJSON(KEY_OPTS, opts);
    });
    confettiToggleEl.addEventListener("change", () => {
      opts.confetti = confettiToggleEl.checked;
      saveJSON(KEY_OPTS, opts);
    });
    loadImagesEl.addEventListener("change", async () => {
      opts.loadImages = loadImagesEl.checked;
      saveJSON(KEY_OPTS, opts);
      renderGrid();
      if (loadImagesEl.checked) await loadImages();
    });

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space"){
        e.preventDefault();
        if (!pickBtn.disabled) doPick();
      }
    });

    renderHistory();
    renderGrid();
    rebuildBag();

    loadImages();

  </script>
</body>
</html>
